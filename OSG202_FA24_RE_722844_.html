<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quiz Template - Single & Multiple Choice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .quiz-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .quiz-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .quiz-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .quiz-header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .score-summary {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-item {
            text-align: center;
        }

        .score-number {
            font-size: 1.5em;
            font-weight: bold;
        }

        .score-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quiz-content {
            padding: 40px;
        }

        .question-item {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .question-item.answered {
            border-color: #28a745;
            background: #f8fff9;
        }

        .question-item.incorrect {
            border-color: #dc3545;
            background: #fff8f8;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .question-status {
            font-size: 1.2em;
        }

        .question-text {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #333;
            line-height: 1.5;
            font-weight: 500;
        }

        .options-container {
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            background: white;
            margin: 8px 0;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-item:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option-item.selected {
            border-color: #667eea;
            background: #e3f2fd;
        }

        .option-item.correct {
            border-color: #28a745;
            background: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .option-item.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
        }

        .option-item.user-selected {
            border-color: #007bff;
            background: #cce7ff;
            font-weight: bold;
        }

        .option-item.user-incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            color: #721c24;
            text-decoration: line-through;
        }

        .answer-indicator {
            margin-left: 10px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .correct-indicator {
            color: #28a745;
        }

        .incorrect-indicator {
            color: #dc3545;
        }

        .explanation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .explanation h4 {
            color: #856404;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 1em;
        }

        .explanation p {
            color: #533f04;
            line-height: 1.5;
            margin: 0;
        }

        .action-buttons {
            background: white;
            padding: 20px 40px;
            border-top: 2px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .icon {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <h1>ÔøΩ Quiz Template</h1>
            <p>Template h·ªó tr·ª£ c·∫£ c√¢u h·ªèi single choice v√† multiple choice</p>
            <div class="score-summary">
                <div class="score-item">
                    <div class="score-number" id="totalQuestions">0</div>
                    <div class="score-label">T·ªïng c√¢u</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="answeredCount">0</div>
                    <div class="score-label">ƒê√£ tr·∫£ l·ªùi</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="correctCount">0</div>
                    <div class="score-label">ƒê√∫ng</div>
                </div>
                <div class="score-item">
                    <div class="score-number" id="scorePercentage">0%</div>
                    <div class="score-label">ƒêi·ªÉm s·ªë</div>
                </div>
            </div>
        </div>

        <div class="quiz-content" id="quizContent">
            <!-- 
            H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng template:
            1. Thay ƒë·ªïi ti√™u ƒë·ªÅ v√† m√¥ t·∫£ trong ph·∫ßn quiz-header
            2. C·∫≠p nh·∫≠t m·∫£ng questions v·ªõi c√¢u h·ªèi c·ªßa b·∫°n
            3. S·ª≠ d·ª•ng type: "single" cho c√¢u h·ªèi m·ªôt ƒë√°p √°n
            4. S·ª≠ d·ª•ng type: "multiple" cho c√¢u h·ªèi nhi·ªÅu ƒë√°p √°n
            5. V·ªõi single choice: correct = index s·ªë (vd: 0, 1, 2)
            6. V·ªõi multiple choice: correct = m·∫£ng index (vd: [0, 2, 3])
            
            V√≠ d·ª• c√¢u h·ªèi single choice:
            {
                id: 1,
                question: "C√¢u h·ªèi c·ªßa b·∫°n?",
                options: ["ƒê√°p √°n A", "ƒê√°p √°n B", "ƒê√°p √°n C", "ƒê√°p √°n D"],
                correct: 0, // ƒê√°p √°n ƒë√∫ng l√† A (index 0)
                type: "single",
                explanation: "Gi·∫£i th√≠ch t·∫°i sao ƒë√°p √°n A ƒë√∫ng"
            }
            
            V√≠ d·ª• c√¢u h·ªèi multiple choice:
            {
                id: 2,
                question: "Ch·ªçn t·∫•t c·∫£ ƒë√°p √°n ƒë√∫ng:",
                options: ["ƒê√°p √°n A", "ƒê√°p √°n B", "ƒê√°p √°n C", "ƒê√°p √°n D"],
                correct: [0, 2], // ƒê√°p √°n ƒë√∫ng l√† A v√† C
                type: "multiple",
                explanation: "Gi·∫£i th√≠ch t·∫°i sao A v√† C ƒë√∫ng"
            }
            -->
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" onclick="resetQuiz()">
                üîÑ L√†m l·∫°i to√†n b·ªô
            </button>
            <div>
                <button class="btn btn-primary" onclick="showAllAnswers()">
                    üëÅÔ∏è Hi·ªán t·∫•t c·∫£ ƒë√°p √°n
                </button>
                <button class="btn btn-success" onclick="checkAllAnswers()">
                    ‚úÖ Ki·ªÉm tra k·∫øt qu·∫£
                </button>
            </div>
        </div>
    </div>

    <script>
        /*
        ===================================================================
        üìù QUIZ TEMPLATE - H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG
        ===================================================================
        
        üéØ T√çNH NƒÇNG:
        ‚úÖ H·ªó tr·ª£ c√¢u h·ªèi Single Choice (ch·ªçn 1 ƒë√°p √°n)
        ‚úÖ H·ªó tr·ª£ c√¢u h·ªèi Multiple Choice (ch·ªçn nhi·ªÅu ƒë√°p √°n)
        ‚úÖ T·ª± ƒë·ªông kh√≥a c√¢u h·ªèi sau khi tr·∫£ l·ªùi
        ‚úÖ Hi·ªÉn th·ªã gi·∫£i th√≠ch ngay l·∫≠p t·ª©c
        ‚úÖ Theo d√µi ƒëi·ªÉm s·ªë realtime
        ‚úÖ Responsive design cho m·ªçi thi·∫øt b·ªã
        
        üîß C√ÅCH S·ª¨ D·ª§NG:
        1. Thay ƒë·ªïi ti√™u ƒë·ªÅ v√† m√¥ t·∫£ trong ph·∫ßn quiz-header
        2. Thay th·∫ø m·∫£ng questions b√™n d∆∞·ªõi b·∫±ng c√¢u h·ªèi c·ªßa b·∫°n
        3. S·ª≠ d·ª•ng type: "single" cho c√¢u h·ªèi m·ªôt ƒë√°p √°n
        4. S·ª≠ d·ª•ng type: "multiple" cho c√¢u h·ªèi nhi·ªÅu ƒë√°p √°n
        
        üìã C·∫§U TR√öC C√ÇU H·ªéI:
        - id: S·ªë th·ª© t·ª± c√¢u h·ªèi (duy nh·∫•t)
        - question: N·ªôi dung c√¢u h·ªèi
        - options: M·∫£ng c√°c ƒë√°p √°n (t·ªëi ƒëa 5 ƒë√°p √°n)
        - correct: ƒê√°p √°n ƒë√∫ng (s·ªë cho single, m·∫£ng cho multiple)
        - type: "single" ho·∫∑c "multiple"
        - explanation: Gi·∫£i th√≠ch chi ti·∫øt
        
        üí° L∆ØU √ù:
        - Index ƒë√°p √°n b·∫Øt ƒë·∫ßu t·ª´ 0 (A=0, B=1, C=2, D=3, E=4)
        - Multiple choice c·∫ßn ch·ªçn ƒë·ªß s·ªë ƒë√°p √°n ƒë√∫ng m·ªõi ƒë∆∞·ª£c kh√≥a
        - Gi·∫£i th√≠ch hi·ªÉn th·ªã ngay sau khi ho√†n th√†nh c√¢u h·ªèi
        ===================================================================
        */
        
        const questions = [
// ========== C√ÇU H·ªéI 1 ==========
{
    id: 1,
    question: "The operating system can be viewed as both a resource manager and an extended machine. From the extended machine perspective, what does the system provide to make the machine easier for users to operate?",
    options: [
        "Provide users with abstract information.",
        "Provide users with progress information.",
        "Provide users with memory information.",
        "Provide users with drive information."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ t·ª´ g√≥c ƒë·ªô m√°y m·ªü r·ªông, h·ªá ƒëi·ªÅu h√†nh cung c·∫•p th√¥ng tin tr·ª´u t∆∞·ª£ng ƒë·ªÉ gi√∫p ng∆∞·ªùi d√πng v·∫≠n h√†nh m√°y d·ªÖ d√†ng h∆°n."
},

// ========== C√ÇU H·ªéI 2 ==========
{
    id: 2,
    question: "What is the structure of a disk drive?",
    options: [
        "Only one metal platter.",
        "Two metal platters.",
        "One or more metal platters.",
        "Many metal platters."
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ ·ªï ƒëƒ©a c√≥ c·∫•u tr√∫c g·ªìm m·ªôt ho·∫∑c nhi·ªÅu ƒëƒ©a kim lo·∫°i."
},

// ========== C√ÇU H·ªéI 3 ==========
{
    id: 3,
    question: "What happens to the Program Counter after an instruction is fetched?",
    options: [
        "It is reset to zero.",
        "It is updated to point to the next instruction.",
        "It is used to store the result of the instruction.",
        "It is used to store the total length of the program being executed."
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ sau khi l·∫•y l·ªánh, b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ tr·ªè ƒë·∫øn l·ªánh ti·∫øp theo."
},

// ========== C√ÇU H·ªéI 4 ==========
{
    id: 4,
    question: "What is the main advantage of multiprocessor systems, such as those used by Windows and Linux?",
    options: [
        "Increased throughput.",
        "Decreased throughput.",
        "Low-speed communication.",
        "Reduced reliability."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ l·ª£i th·∫ø ch√≠nh c·ªßa h·ªá th·ªëng ƒëa x·ª≠ l√Ω l√† tƒÉng th√¥ng l∆∞·ª£ng."
},

// ========== C√ÇU H·ªéI 5 ==========
{
    id: 5,
    question: "Which of the following is NOT part of the operating system?",
    options: [
        "Performance monitor.",
        "Input/Output control program.",
        "Job control program.",
        "Supervisor."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ Performance monitor kh√¥ng ph·∫£i l√† th√†nh ph·∫ßn c·ªßa h·ªá ƒëi·ªÅu h√†nh."
},

// ========== C√ÇU H·ªéI 6 ==========
{
    id: 6,
    question: "In Unix, which command is used to move the file pointer?",
    options: [
        "Write.",
        "Mount.",
        "Link.",
        "Iseek."
    ],
    correct: 3,
    type: "single",
    explanation: "ƒê√°p √°n D ƒë√∫ng v√¨ trong Unix, l·ªánh Iseek ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ di chuy·ªÉn con tr·ªè file."
},

// ========== C√ÇU H·ªéI 7 ==========
{
    id: 7,
    question: "In a monolithic system, a simple structuring model includes:",
    options: [
        "Main procedure.",
        "Service procedures.",
        "Utility procedures.",
        "All of the above."
    ],
    correct: 3,
    type: "single",
    explanation: "ƒê√°p √°n D ƒë√∫ng v√¨ trong h·ªá th·ªëng monolithic, m√¥ h√¨nh c·∫•u tr√∫c ƒë∆°n gi·∫£n bao g·ªìm Main procedure, Service procedures v√† Utility procedures."
},

// ========== C√ÇU H·ªéI 8 ==========
{
    id: 8,
    question: "What are the basic states of a process?",
    options: [
        "Running, Ready, and Blocked.",
        "Running, Blocked, and Exit.",
        "Create, Running, and Exit.",
        "Create, Running, and Blocked."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ c√°c tr·∫°ng th√°i c∆° b·∫£n c·ªßa m·ªôt ti·∫øn tr√¨nh l√† Running (ƒëang ch·∫°y), Ready (s·∫µn s√†ng) v√† Blocked (b·ªã ch·∫∑n)."
},

// ========== C√ÇU H·ªéI 9 ==========
{
    id: 9,
    question: "Which of the following process state transitions is illegal?",
    options: [
        "Ready ‚Üí Blocked (waiting).",
        "Running ‚Üí Blocked (waiting).",
        "Blocked ‚Üí Ready.",
        "Running ‚Üí Ready."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ chuy·ªÉn ƒë·ªïi t·ª´ Ready sang Blocked l√† kh√¥ng h·ª£p l·ªá. Ti·∫øn tr√¨nh ·ªü tr·∫°ng th√°i Ready kh√¥ng th·ªÉ chuy·ªÉn tr·ª±c ti·∫øp sang Blocked."
},

// ========== C√ÇU H·ªéI 10 ==========
{
    id: 10,
    question: "A computer has 4GB of RAM, with 2GB used by the operating system. Each process is 1024MB and behaves the same. If the processes are idle and waiting for I/O 50% of the time, what is the CPU utilization?",
    options: [
        "75%",
        "90%",
        "1%",
        "50%"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng. T√≠nh to√°n: B·ªô nh·ªõ kh·∫£ d·ª•ng = 4GB - 2GB = 2GB = 2048MB. S·ªë process c√≥ th·ªÉ ch·∫°y = 2048MB / 1024MB = 2 process. CPU utilization = 1 - (0.5)^2 = 1 - 0.25 = 0.75 = 75%."
},

// ========== C√ÇU H·ªéI 11 ==========
{
    id: 11,
    question: "What defines a critical section in the context of the Windows operating system?",
    options: [
        "A section of code where the processor executes multiple threads simultaneously.",
        "A section of code where hardware interrupts are disabled.",
        "A segment of code that only one thread can execute at a time to avoid conflicts.",
        "A part of the kernel where system-level processes have higher priority than user processes."
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ critical section l√† ƒëo·∫°n m√£ m√† ch·ªâ m·ªôt thread c√≥ th·ªÉ th·ª±c thi t·∫°i m·ªôt th·ªùi ƒëi·ªÉm ƒë·ªÉ tr√°nh xung ƒë·ªôt."
},

// ========== C√ÇU H·ªéI 12 ==========
{
    id: 12,
    question: "When a process is running in a contention zone and no other processes are running in that zone, what is this condition called?",
    options: [
        "Mutual exclusion.",
        "Bounded-waiting.",
        "Progress.",
        "Critical exclusion."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ ƒë√¢y l√† ƒëi·ªÅu ki·ªán lo·∫°i tr·ª´ l·∫´n nhau (Mutual exclusion)."
},

// ========== C√ÇU H·ªéI 13 ==========
{
    id: 13,
    question: "A preemptive version of Shortest Job First (SJF) scheduling is:",
    options: [
        "Shortest Process Next.",
        "First-Come, First-Served.",
        "Shortest Remaining Time Next.",
        "Shortest Used Time."
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ Shortest Remaining Time Next l√† phi√™n b·∫£n chi·∫øm ∆∞u th·∫ø c·ªßa SJF."
},

// ========== C√ÇU H·ªéI 14 ==========
{
    id: 14,
    question: "Which page table entry bit is used to indicate types of permitted access?",
    options: [
        "Present/absent bit.",
        "Caching disabled.",
        "Protection bit.",
        "Modified bit."
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ Protection bit ch·ªâ ra c√°c lo·∫°i truy c·∫≠p ƒë∆∞·ª£c ph√©p."
},

// ========== C√ÇU H·ªéI 15 ==========
{
    id: 15,
    question: "What is the address that the main memory unit sees and manipulates called?",
    options: [
        "Physical address.",
        "Address space.",
        "Physical space.",
        "Logical address."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ ƒë·ªãa ch·ªâ m√† b·ªô nh·ªõ ch√≠nh nh√¨n th·∫•y v√† thao t√°c ƒë∆∞·ª£c g·ªçi l√† ƒë·ªãa ch·ªâ v·∫≠t l√Ω (Physical address)."
},

// ========== C√ÇU H·ªéI 16 ==========
{
    id: 16,
    question: "Which memory management technique uses a binary representation where each bit corresponds to an allocation unit?",
    options: [
        "Bitmap.",
        "Linked List.",
        "Paging.",
        "Partition."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ k·ªπ thu·∫≠t Bitmap s·ª≠ d·ª•ng bi·ªÉu di·ªÖn nh·ªã ph√¢n trong ƒë√≥ m·ªói bit t∆∞∆°ng ·ª©ng v·ªõi m·ªôt ƒë∆°n v·ªã c·∫•p ph√°t."
},

// ========== C√ÇU H·ªéI 17 ==========
{
    id: 17,
    question: "A process that needs 12KB of memory is placed into a 20KB block. Which memory allocation method is used?",
    options: [
        "Worst-fit.",
        "First-fit.",
        "Best-fit.",
        "Next-fit."
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ Worst-fit s·∫Ω ƒë·∫∑t process v√†o kh·ªëi nh·ªõ l·ªõn nh·∫•t c√≥ s·∫µn (20KB)."
},

// ========== C√ÇU H·ªéI 18 ==========
{
    id: 18,
    question: "Most virtual memory systems use a technique called:",
    options: [
        "Page Fault.",
        "Page Frames.",
        "Page Table.",
        "Paging."
    ],
    correct: 3,
    type: "single",
    explanation: "ƒê√°p √°n D ƒë√∫ng v√¨ h·∫ßu h·∫øt c√°c h·ªá th·ªëng b·ªô nh·ªõ ·∫£o s·ª≠ d·ª•ng k·ªπ thu·∫≠t ph√¢n trang (Paging)."
},

// ========== C√ÇU H·ªéI 19 ==========
{
    id: 19,
    question: "A computer with a 32-bit address uses a two-level page table. If virtual addresses are split into a 10-bit top-level field, a 12-bit second-level field, and an offset, what is the page size?",
    options: [
        "512B page.",
        "1-KB page.",
        "2-KB page.",
        "4-KB page."
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng. T√≠nh to√°n: Offset = 32 - 10 - 12 = 10 bits. Page size = 2^10 = 1024 bytes = 1KB."
},

// ========== C√ÇU H·ªéI 20 ==========
{
    id: 20,
    question: "If FIFO page replacement is used with three page frames, how many page faults occur with the reference string: 1, 3, 0, 3, 5, 6 (frames initially empty)?",
    options: [
        "6",
        "4",
        "7",
        "3"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng. T√≠nh to√°n v·ªõi chu·ªói tham chi·∫øu 1,3,0,3,5,6 v√† 3 khung trang s·∫Ω cho 6 l·ªói trang."
},

// ========== C√ÇU H·ªéI 21 ==========
{
    id: 21,
    question: "If FIFO page replacement is used with three page frames, how many page faults will occur with the reference string 1, 2, 3, 4, 1, 2 (assuming the frames are initially empty)?",
    options: [
        "6",
        "4",
        "5",
        "3"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng. T√≠nh to√°n v·ªõi chu·ªói tham chi·∫øu 1,2,3,4,1,2 v√† 3 khung trang s·∫Ω cho 6 l·ªói trang."
},

// ========== C√ÇU H·ªéI 22 ==========
{
    id: 22,
    question: "When a new process is created in a paging system, which timing is used to determine program size and create the page table?",
    options: [
        "Process creation time",
        "Process execution time",
        "Page fault time",
        "Process termination time"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ khi t·∫°o process m·ªõi trong h·ªá th·ªëng ph√¢n trang, th·ªùi ƒëi·ªÉm t·∫°o process ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x√°c ƒë·ªãnh k√≠ch th∆∞·ªõc ch∆∞∆°ng tr√¨nh v√† t·∫°o b·∫£ng trang."
},

// ========== C√ÇU H·ªéI 23 ==========
{
    id: 23,
    question: "In memory management, what is the primary advantage of segmented memory over paging?",
    options: [
        "Simplified address translation",
        "Efficient use of memory space",
        "Reduced overhead in memory management",
        "Elimination of fragmentation"
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ l·ª£i th·∫ø ch√≠nh c·ªßa b·ªô nh·ªõ ph√¢n ƒëo·∫°n so v·ªõi ph√¢n trang l√† s·ª≠ d·ª•ng b·ªô nh·ªõ hi·ªáu qu·∫£ h∆°n."
},

// ========== C√ÇU H·ªéI 24 ==========
{
    id: 24,
    question: "In a file access system, random access files are important for applications like databases. What two methods are used to specify where to start reading?",
    options: [
        "Write and Read",
        "Write and Seek",
        "Read and Seek",
        "Read and Write"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ Read v√† Seek l√† hai ph∆∞∆°ng th·ª©c ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ch·ªâ ƒë·ªãnh n∆°i b·∫Øt ƒë·∫ßu ƒë·ªçc."
},

// ========== C√ÇU H·ªéI 25 ==========
{
    id: 25,
    question: "In UNIX, which type of file is used to model disks?",
    options: [
        "Regular files",
        "Character special files",
        "Block special files",
        "Directories"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ trong UNIX, block special files ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ m√¥ h√¨nh h√≥a ƒëƒ©a."
},

// ========== C√ÇU H·ªéI 26 ==========
{
    id: 26,
    question: "What is the state of a file when the process finishes and the file can be accessed by other processes?",
    options: [
        "Exit",
        "Terminate",
        "Exist",
        "Suspend"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ tr·∫°ng th√°i c·ªßa file l√† Exist (t·ªìn t·∫°i) khi process k·∫øt th√∫c v√† file c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p b·ªüi c√°c process kh√°c."
},

// ========== C√ÇU H·ªéI 27 ==========
{
    id: 27,
    question: "After a directory is read, what should be done to free internal table space?",
    options: [
        "Close",
        "Closedir",
        "Delete",
        "Opendir"
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ h√†m closedir ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë√≥ng th∆∞ m·ª•c sau khi ƒë·ªçc v√† gi·∫£i ph√≥ng kh√¥ng gian b·∫£ng n·ªôi b·ªô."
},

// ========== C√ÇU H·ªéI 28 ==========
{
    id: 28,
    question: "The simplest form of directory system, where one directory contains all files, is called the:",
    options: [
        "Root directory",
        "User directory",
        "Parent directory",
        "Current directory"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ h·ªá th·ªëng th∆∞ m·ª•c ƒë∆°n gi·∫£n nh·∫•t, n∆°i m·ªôt th∆∞ m·ª•c ch·ª©a t·∫•t c·∫£ c√°c file, ƒë∆∞·ª£c g·ªçi l√† th∆∞ m·ª•c g·ªëc (Root directory)."
},

// ========== C√ÇU H·ªéI 29 ==========
{
    id: 29,
    question: "Sector 0 of the disk, used to boot the computer, is called the:",
    options: [
        "DMA",
        "MBR",
        "FAT",
        "NTFS"
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ sector 0 c·ªßa ƒëƒ©a, ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ kh·ªüi ƒë·ªông m√°y t√≠nh, ƒë∆∞·ª£c g·ªçi l√† MBR (Master Boot Record)."
},

// ========== C√ÇU H·ªéI 30 ==========
{
    id: 30,
    question: "When the computer is booted, what is used to read and execute the boot process?",
    options: [
        "BIOS, Boot Block",
        "CPU, BIOS",
        "BIOS, MBR",
        "MBR, BIOS"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ khi m√°y t√≠nh kh·ªüi ƒë·ªông, BIOS v√† MBR ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·ªçc v√† th·ª±c thi qu√° tr√¨nh kh·ªüi ƒë·ªông."
},

// ========== C√ÇU H·ªéI 31 ==========
{
    id: 31,
    question: "Disk can be divided into one or more partitions. The first block of every partition is called:",
    options: [
        "Boot block",
        "Free block",
        "Super block",
        "MBR"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ kh·ªëi ƒë·∫ßu ti√™n c·ªßa m·ªói partition ƒë∆∞·ª£c g·ªçi l√† boot block."
},

// ========== C√ÇU H·ªéI 32 ==========
{
    id: 32,
    question: "In Windows 95, what is the maximum partition size if the FAT type is FAT-32 and the block size is 16 KB?",
    options: [
        "1 TB",
        "2 TB",
        "512 MB",
        "128 MB"
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ v·ªõi FAT-32 v√† k√≠ch th∆∞·ªõc block 16 KB, k√≠ch th∆∞·ªõc partition t·ªëi ƒëa l√† 2 TB."
},

// ========== C√ÇU H·ªéI 33 ==========
{
    id: 33,
    question: "In a DMA transfer cycle, what two modes can many buses operate in?",
    options: [
        "Word-at-a-time mode and byte mode",
        "Word-at-a-time mode and block mode",
        "Word-at-a-time mode and bit mode",
        "Word-at-a-time mode and page mode"
    ],
    correct: 1,
    type: "single",
    explanation: "ƒê√°p √°n B ƒë√∫ng v√¨ trong chu k·ª≥ chuy·ªÉn DMA, nhi·ªÅu bus c√≥ th·ªÉ ho·∫°t ƒë·ªông ·ªü ch·∫ø ƒë·ªô Word-at-a-time v√† Block mode."
},

// ========== C√ÇU H·ªéI 34 ==========
{
    id: 34,
    question: "An interrupt has four properties: 1) The PC (Program Counter) is saved in a known place. 2) All instructions before the one pointed to by the PC have completed. 3) No instruction beyond the one pointed to by the PC has finished. 4) The execution state of the instruction pointed to by the PC is known. What type of interrupt is this?",
    options: [
        "Imprecise interrupt",
        "Synchronous interrupt",
        "Sequential interrupt",
        "Precise interrupt"
    ],
    correct: 3,
    type: "single",
    explanation: "ƒê√°p √°n D ƒë√∫ng v√¨ ƒë√¢y l√† m√¥ t·∫£ c·ªßa ng·∫Øt ch√≠nh x√°c (Precise interrupt)."
},

// ========== C√ÇU H·ªéI 35 ==========
{
    id: 35,
    question: "Which I/O mode is most suitable for transferring data between memory and I/O devices without the CPU being bothered?",
    options: [
        "Direct Memory Access",
        "Programmed I/O",
        "Interrupt-driven I/O",
        "Polling"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ DMA ph√π h·ª£p nh·∫•t ƒë·ªÉ chuy·ªÉn d·ªØ li·ªáu gi·ªØa b·ªô nh·ªõ v√† thi·∫øt b·ªã I/O m√† kh√¥ng l√†m phi·ªÅn CPU."
},

// ========== C√ÇU H·ªéI 36 ==========
{
    id: 36,
    question: "What does the term 'blocking' refer to in the context of I/O software?",
    options: [
        "A technique for managing device drivers",
        "A mechanism for ensuring device synchronization",
        "The process of stopping a process until an I/O operation is completed",
        "A method of allocating memory for I/O operations"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ 'blocking' ƒë·ªÅ c·∫≠p ƒë·∫øn qu√° tr√¨nh d·ª´ng m·ªôt process cho ƒë·∫øn khi ho·∫°t ƒë·ªông I/O ho√†n t·∫•t."
},

// ========== C√ÇU H·ªéI 37 ==========
{
    id: 37,
    question: "Which of the following is NOT a responsibility of the Device-Independent I/O Software layer?",
    options: [
        "Uniform interfacing for device drivers",
        "Allocating and releasing dedicated devices",
        "Providing a device-independent block size",
        "Allocating port numbers to I/O devices",
        "Error handling",
        "Buffering"
    ],
    correct: 3,
    type: "single",
    explanation: "ƒê√°p √°n D ƒë√∫ng v√¨ c·∫•p ph√°t s·ªë c·ªïng cho thi·∫øt b·ªã I/O KH√îNG ph·∫£i l√† tr√°ch nhi·ªám c·ªßa l·ªõp ph·∫ßn m·ªÅm I/O ƒë·ªôc l·∫≠p thi·∫øt b·ªã."
},

// ========== C√ÇU H·ªéI 38 ==========
{
    id: 38,
    question: "RAID level ___ works worst with operating systems that habitually ask for data one sector at a time.",
    options: [
        "0",
        "1",
        "2",
        "3"
    ],
    correct: 0,
    type: "single",
    explanation: "ƒê√°p √°n A ƒë√∫ng v√¨ RAID level 0 ho·∫°t ƒë·ªông k√©m nh·∫•t v·ªõi h·ªá ƒëi·ªÅu h√†nh th∆∞·ªùng xuy√™n y√™u c·∫ßu d·ªØ li·ªáu m·ªôt sector t·∫°i m·ªôt th·ªùi ƒëi·ªÉm."
},

// ========== C√ÇU H·ªéI 39 ==========
{
    id: 39,
    question: "Which operation in stable storage involves writing and verifying a block on both drives until it is successfully written and verified?",
    options: [
        "Stable read",
        "Crash recovery",
        "Stable write",
        "Data synchronization"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ Stable write li√™n quan ƒë·∫øn vi·ªác ghi v√† x√°c minh m·ªôt kh·ªëi tr√™n c·∫£ hai ·ªï ƒëƒ©a cho ƒë·∫øn khi n√≥ ƒë∆∞·ª£c ghi v√† x√°c minh th√†nh c√¥ng."
},

// ========== C√ÇU H·ªéI 40 ==========
{
    id: 40,
    question: "Which type of clock in a computer system keeps track of the current time and date and is typically battery-powered to retain data even when the system is turned off?",
    options: [
        "System clock",
        "CPU clock",
        "Real-time clock (RTC)",
        "Network clock"
    ],
    correct: 2,
    type: "single",
    explanation: "ƒê√°p √°n C ƒë√∫ng v√¨ Real-time clock (RTC) theo d√µi th·ªùi gian v√† ng√†y hi·ªán t·∫°i, th∆∞·ªùng ƒë∆∞·ª£c c·∫•p ngu·ªìn b·∫±ng pin ƒë·ªÉ gi·ªØ d·ªØ li·ªáu ngay c·∫£ khi h·ªá th·ªëng t·∫Øt."
}
];

        let userAnswers = {};
        let showingAnswers = false;
        let answeredQuestions = new Set(); // Add tracking

        function initQuiz() {
            // T·ª± ƒë·ªông c·∫≠p nh·∫≠t t·ªïng s·ªë c√¢u h·ªèi
            document.getElementById('totalQuestions').textContent = questions.length;
            
            renderAllQuestions();
            updateScoreSummary();
        }

        function renderAllQuestions() {
            const quizContent = document.getElementById('quizContent');
            
            quizContent.innerHTML = questions.map(question => `
                <div class="question-item" id="question-${question.id}">
                    <div class="question-header">
                        <div class="question-number">C√¢u ${question.id}</div>
                        <div class="question-status" id="status-${question.id}">‚ùì</div>
                    </div>
                    
                    <div class="question-text">${question.question}</div>
                    
                    <div class="options-container">
                        ${question.options.map((option, index) => `
                            <div class="option-item" onclick="selectOption(${question.id}, ${index})">
                                ${question.type === 'multiple' ? 
                                    `<input type="checkbox" class="option-checkbox" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">` :
                                    `<input type="radio" name="q${question.id}" class="option-radio" id="q${question.id}-opt${index}" onchange="selectOption(${question.id}, ${index})">`
                                }
                                <label class="option-text" for="q${question.id}-opt${index}">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="explanation" id="explanation-${question.id}">
                        <h4><span class="icon">üí°</span>Gi·∫£i th√≠ch:</h4>
                        <p>${question.explanation}</p>
                    </div>
                </div>
            `).join('');
        }

        function selectOption(questionId, optionIndex) {
            // Prevent changes if question already answered
            if (answeredQuestions.has(questionId)) {
                return;
            }
            
            const question = questions.find(q => q.id === questionId);
            const questionElement = document.getElementById(`question-${questionId}`);
            const optionElement = document.getElementById(`q${questionId}-opt${optionIndex}`);
            
            if (showingAnswers) return;
            
            if (question.type === 'multiple') {
                // Handle multiple choice
                if (!userAnswers[questionId]) {
                    userAnswers[questionId] = [];
                }
                
                if (optionElement.checked) {
                    if (!userAnswers[questionId].includes(optionIndex)) {
                        userAnswers[questionId].push(optionIndex);
                    }
                } else {
                    userAnswers[questionId] = userAnswers[questionId].filter(idx => idx !== optionIndex);
                }
                
                // Check if user has selected the correct number of answers for multiple choice
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                if (userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length) {
                    answeredQuestions.add(questionId);
                    disableQuestionOptions(questionId);
                    showQuestionFeedback(questionId);
                } else {
                    hideQuestionFeedback(questionId);
                }
            } else {
                // Handle single choice - lock immediately
                userAnswers[questionId] = optionIndex;
                answeredQuestions.add(questionId);
                disableQuestionOptions(questionId);
                showQuestionFeedback(questionId);
            }
            
            updateQuestionStatus(questionId);
            updateScoreSummary();
        }

        function disableQuestionOptions(questionId) {
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach(element => {
                element.disabled = true;
                element.parentElement.style.pointerEvents = 'none';
                element.parentElement.style.opacity = '0.7';
            });
        }

        function showQuestionFeedback(questionId) {
            const question = questions.find(q => q.id === questionId);
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            const isCorrect = checkAnswer(questionId);
            
            // Show explanation
            explanationElement.classList.add('show');
            
            // Update option styling to show correct/incorrect
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                const userAnswer = userAnswers[questionId];
                const isUserSelection = question.type === 'multiple' ? 
                    (userAnswer && userAnswer.includes(index)) : 
                    (userAnswer === index);
                
                if (question.type === 'multiple') {
                    const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                    
                    if (correctAnswers.includes(index)) {
                        // This is a correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                } else {
                    if (index === question.correct) {
                        // This is the correct answer
                        optionContainer.classList.add('correct');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator correct-indicator';
                        indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng' : '‚úì ƒê√°p √°n ƒë√∫ng';
                        optionContainer.appendChild(indicator);
                    } else if (isUserSelection) {
                        // User selected wrong answer
                        optionContainer.classList.add('user-incorrect');
                        const indicator = document.createElement('span');
                        indicator.className = 'answer-indicator incorrect-indicator';
                        indicator.textContent = '‚úó Sai';
                        optionContainer.appendChild(indicator);
                    }
                }
            });
        }

        function hideQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            explanationElement.classList.remove('show');
            
            // Remove feedback styling from options
            const optionElements = document.querySelectorAll(`[id^="q${questionId}-opt"]`);
            optionElements.forEach((element, index) => {
                const optionContainer = element.parentElement;
                optionContainer.classList.remove('correct', 'incorrect', 'user-selected', 'user-incorrect');
                
                // Remove existing indicators
                const existingIndicator = optionContainer.querySelector('.answer-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
            });
        }

        function updateQuestionStatus(questionId) {
            const question = questions.find(q => q.id === questionId);
            const statusElement = document.getElementById(`status-${questionId}`);
            const questionElement = document.getElementById(`question-${questionId}`);
            
            // Check if question is properly answered
            let isAnswered = false;
            if (question.type === 'multiple') {
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                isAnswered = userAnswers[questionId] && userAnswers[questionId].length === correctAnswers.length;
            } else {
                isAnswered = userAnswers[questionId] !== undefined;
            }
            
            if (isAnswered) {
                if (showingAnswers || hasQuestionFeedback(questionId)) {
                    const isCorrect = checkAnswer(questionId);
                    statusElement.textContent = isCorrect ? '‚úÖ' : '‚ùå';
                    questionElement.className = `question-item ${isCorrect ? 'answered' : 'incorrect'}`;
                } else {
                    statusElement.textContent = '‚úèÔ∏è';
                    questionElement.className = 'question-item answered';
                }
            } else {
                statusElement.textContent = '‚ùì';
                questionElement.className = 'question-item';
            }
        }

        function hasQuestionFeedback(questionId) {
            const explanationElement = document.getElementById(`explanation-${questionId}`);
            return explanationElement.classList.contains('show');
        }

        function checkAnswer(questionId) {
            const question = questions.find(q => q.id === questionId);
            const userAnswer = userAnswers[questionId];
            
            if (question.type === 'multiple') {
                if (!userAnswer || userAnswer.length === 0) return false;
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                return userAnswer.length === correctAnswers.length && 
                       userAnswer.every(ans => correctAnswers.includes(ans));
            } else {
                return userAnswer === question.correct;
            }
        }

        function updateScoreSummary() {
            const answeredCount = Object.keys(userAnswers).filter(qId => {
                const question = questions.find(q => q.id == qId);
                const answer = userAnswers[qId];
                return answer !== undefined && 
                       (question.type === 'single' || (question.type === 'multiple' && answer.length > 0));
            }).length;
            
            const correctCount = Object.keys(userAnswers).filter(qId => checkAnswer(parseInt(qId))).length;
            const percentage = answeredCount > 0 ? Math.round((correctCount / questions.length) * 100) : 0;
            
            document.getElementById('answeredCount').textContent = answeredCount;
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('scorePercentage').textContent = percentage + '%';
        }

        function showAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Highlight correct answers only
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        if (correctAnswers.includes(index)) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function checkAllAnswers() {
            showingAnswers = true;
            
            questions.forEach(question => {
                const explanationElement = document.getElementById(`explanation-${question.id}`);
                explanationElement.classList.add('show');
                
                // Show user answers vs correct answers
                const optionElements = document.querySelectorAll(`[id^="q${question.id}-opt"]`);
                optionElements.forEach((element, index) => {
                    const optionContainer = element.parentElement;
                    optionContainer.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                    
                    // Remove existing indicators
                    const existingIndicator = optionContainer.querySelector('.answer-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    const userAnswer = userAnswers[question.id];
                    const isUserSelection = question.type === 'multiple' ? 
                        (userAnswer && userAnswer.includes(index)) : 
                        (userAnswer === index);
                    
                    if (question.type === 'multiple') {
                        const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                        
                        if (correctAnswers.includes(index)) {
                            // This is a correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    } else {
                        if (index === question.correct) {
                            // This is the correct answer
                            optionContainer.classList.add('correct');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator correct-indicator';
                            indicator.textContent = isUserSelection ? '‚úì ƒê√∫ng - B·∫°n ƒë√£ ch·ªçn' : '‚úì ƒê√°p √°n ƒë√∫ng';
                            optionContainer.appendChild(indicator);
                        } else if (isUserSelection) {
                            // User selected wrong answer
                            optionContainer.classList.add('user-incorrect');
                            const indicator = document.createElement('span');
                            indicator.className = 'answer-indicator incorrect-indicator';
                            indicator.textContent = '‚úó Sai - B·∫°n ƒë√£ ch·ªçn';
                            optionContainer.appendChild(indicator);
                        }
                    }
                    
                    // Disable further interactions
                    element.disabled = true;
                });
                
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        function resetQuiz() {
            userAnswers = {};
            showingAnswers = false;
            answeredQuestions.clear();
            
            // Reset all form elements
            document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
                input.checked = false;
                input.disabled = false;
                input.parentElement.style.pointerEvents = 'auto';
                input.parentElement.style.opacity = '1';
            });
            
            // Hide all explanations and feedback
            questions.forEach(question => {
                hideQuestionFeedback(question.id);
            });
            
            // Reset all option styling and remove indicators
            document.querySelectorAll('.option-item').forEach(option => {
                option.classList.remove('correct', 'incorrect', 'selected', 'user-selected', 'user-incorrect');
                const indicator = option.querySelector('.answer-indicator');
                if (indicator) {
                    indicator.remove();
                }
            });
            
            // Update all question statuses
            questions.forEach(question => {
                updateQuestionStatus(question.id);
            });
            
            updateScoreSummary();
        }

        // Initialize quiz when page loads
        document.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>
